<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Seek Truth</title>
    <meta charset="utf-8">
    <link rel="stylesheet"
        href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/vs.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/npm/clamp-js-main@0.11.6/clamp.min.js"></script>
    
<link rel="stylesheet" href="/css/font.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Seek Truth" type="application/atom+xml">
</head>

<body>
    <header class="header">
    <div class="blog-title">
        <a href="/" class="logo">Seek Truth</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                
                
                <li class="menu-item">
                    <a href="/" class="menu-item-link">Posts</a>
                </li>
            
                
                
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">RSS</a>
                </li>
            
                
                
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/MU001999" class="menu-item-link">Github</a>
                </li>
            
        </ul>
    </nav>
</header>

    <main class="main">
        <section class="posts">
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2022/02/17/Memory-Management-in-Rust/">Memory Management in Rust</a>
        </div>
        <div class="post-meta">
            <span class="post-time">February 17, 2022</span>
        </div>
        <div class="post-pre" id="Memory Management in Rust">
            <p>程序在运行时需要请求操作系统分配内存以及释放内存，因此，程序员在编写程序时，需要显式（手动）地编写分配和释放内存的代码，或者隐式（自动，由语言保证）地进行内存管理。对于前者，C/C++ 是代表语言，程序员需要手动管理内存；对于后者，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">垃圾回收器</a>（Garbage collector, GC）是一种常见的选择，诸如 Go/Java 等都提供了 GC。</p>
<blockquote>
<p>事实上，C++ 标准库中提供了<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory">智能指针</a>等工具，能够解决一部分的内存管理问题。但是由于 C++ 的高自由度，即使在使用智能指针时，仍十分容易编写出会导致内存错误的代码。</p>
</blockquote>
<p>朴素的手动内存管理对程序员的要求更高，也意味着更容易出错，导致一些内存错误的产生，比如：</p>
<ul>
<li>解引用存储已释放空间的地址的指针（Use after free）</li>
<li>没有释放空间导致的内存泄漏（Memory leak）</li>
<li>重复释放已经被重用的空间（Double free）</li>
</ul>
<p>一个自动的内存管理机制，可以消除这些常见问题。GC 通过在运行时记录分配的空间和空间的使用信息来实现内存的自动管理，程序员就可以从内存管理中解放。<strong>但是</strong>，尽管这件事听起来还不错，但它意味着我们编写的程序在运行时，还附带着运行一个 GC，这当然会带来一些运行时的损耗。</p>
<p>如果你不想在运行时带着一个 GC，又不想像 C/C++ 一样手动检查违反了内存安全的代码的存在，那么可以看看 Rust 的解决方案。Rust 提供了一种不借助 GC，又能够保证内存安全的高效内存管理方式。</p>
<h2 id="所有权-——-大厦的基石">所有权 —— 大厦的基石</h2>
<p><strong>所有权</strong>（<em>Ownership</em>）是 Rust 最重要的特性之一，也是 Rust 能够高效地保证内存安全的同时避免引入 GC 的核心机制。</p>
<p>所有权是一组规则，描述了 Rust 程序如何管理内存。在 Rust 中，内存通过所有权系统来管理，该系统有一套由编译器进行检查的规则（即所有权规则），如果违反了任何一条规则，程序就不能被成功编译。因此，所有权是一组静态的、在编译时检查的规则。这意味着所有权系统不会带来运行时的损耗。</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-rules">所有权规则</a>有且只有如下三条规则：</p>
<ul>
<li>Rust 中的每个值都有一个被称为其<strong>所有者</strong>（<em>Owner</em>）的变量。</li>
<li>一个值在任一时刻有且只有一个所有者。</li>
<li>当所有者离开作用域时，这个值将被丢弃。</li>
</ul>
<p>或许你认为这和大部分（OOP）语言中栈上对象在函数结束时进行析构，同时释放资源（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>）的编程习惯似乎区别不大，事实上也确实如此，区别在于 Rust 将这种规则扩大到了所有值上，包括储存在堆上的值，并且由编译器保证。换言之，Rust enforces RAII。因此，在 Rust 中任何一个值（无论在栈上还是堆上），在不使用时（其所有者离开作用域）都将被丢弃（占用的空间被释放）。你可能已经发现了，没有内存泄漏的世界完成了。</p>
<p>然而，目前的世界十分简陋，如果只有这三条规则，一个简单的实现是在赋值时复制数据并创建一个新值，尽管这样的实现不违背所有权规则，但却是低效的。因此，本文的剩余部分介绍 Rust 中和所有权相关的其它组成部分，这些部分在不违背所有权规则的基础上，和所有权系统共同组成了 Rust 高效的内存安全世界。</p>
<h3 id="移动">移动</h3>
<p>通常来说，复制堆上的数据被认为是缓慢的，因为堆上的数据通常较大，并且在复制时需要申请新的空间；而复制栈上的数据被认为是快速的，因为栈上的数据通常较小，并且类型的大小在编译时已知。</p>
<p>以 Rust 中的 <code>String</code> 类型为例，与其它语言中的字符串类型相似，<code>String</code> 类型由三部分组成：一个指向存放字符串内容（占用堆上空间）的指针，一个长度和一个容量。而这些数据存储在栈上。当一个 <code>String</code> 类型的值被丢弃时，就需要根据栈上存储的数据释放占用的堆上空间。</p>
<p>因此，为了避免复制堆上的数据，一种解决方案是允许在赋值时仅复制 <code>String</code> 在栈上的数据，但是这意味着堆上的空间此时分别被两个变量所有，在失效时会重复释放同一处堆上空间导致内存错误，同时也违背了所有权规则。对此，Rust 的解决方案是在复制了栈上数据之后，将该值的所有权转移给新变量，在当前作用域结束后，之前的所有者便不会再尝试释放堆上的空间。值的所有权的转移在 Rust 中被称为值的<strong>移动</strong>（<em>Move</em>）。同时，移动是 Rust 中赋值的默认行为。</p>
<p>Rust 中，变量的声明通过 <code>let</code> 语句完成，作用域与其它编程语言类似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123; <span class="hljs-comment">// s 在这里无效，它尚未声明</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 从这里开始 s 是有效的</span><br>    <span class="hljs-comment">// 使用 s</span><br>&#125; <span class="hljs-comment">// 在此之后，s 离开当前作用域，不再有效</span><br></code></pre></td></tr></table></figure>
<p>在赋值后，变量 <code>s</code> 绑定到了 <code>String</code> 类型的一个值，此时 <code>s</code> 是该值的所有者。而当 <code>s</code> 离开当前作用域后便不再有效，此时其绑定的值会被丢弃。那么当我们允许值的移动时，将另一个拥有 <code>String</code> 类型的值的变量赋值给新变量会发生什么？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br><span class="hljs-comment">// 此时使用 s1 会发生什么？</span><br></code></pre></td></tr></table></figure>
<p>答案是 <code>s1</code> 的值会被移动给 <code>s2</code>，Rust 会认为 <code>s1</code> 不再有效，如果你此时使用 <code>s1</code>，编译会失败并得到一个错误：<code>s1</code> 的值已经被移动。而在所有权发生转移时，如前文所说，<code>s2</code> 其实复制了 <code>s1</code> 栈上的数据，并在此时令 <code>s1</code> 失效，避免两者在离开作用域时重复释放同一处堆上空间引发内存错误。</p>
<h3 id="克隆和拷贝">克隆和拷贝</h3>
<p>有时我们确实需要复制 <code>String</code> 中的所有数据（包括堆上的数据），在 Rust 中被称为<strong>克隆</strong>（<em>Clone</em>），可以通过显式调用通用方法 <code>clone</code> 实现这样的功能。克隆会产生一个数据相同的新值，此时 <code>s1</code> 和 <code>s2</code> 分别是两个 <code>String</code> 的所有者：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br><span class="hljs-comment">// s1 和 s2 都有效</span><br></code></pre></td></tr></table></figure>
<p>前面提到了，移动时复制的是栈上的数据，而使之前的所有者失效，是为了避免重复释放空间。但是，除了像 <code>String</code> 一样在占用了堆上空间的类型，还有像整型一样所有数据都存储在栈上的类型。这些类型不需要释放堆上空间，意味着不需要令之前的所有者失效。因此，Rust 提供了一个叫做 <code>Copy</code> trait 的类型注解用于这些类型，对于满足 <code>Copy</code> trait 的类型，赋值时会产生一个新值，行为与克隆相似，但不需要显式指定，在 Rust 中被称为<strong>拷贝</strong>（<em>Copy</em>）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br><span class="hljs-comment">// x 和 y 都有效</span><br></code></pre></td></tr></table></figure>
<p>因此，在 Rust 中，移动是赋值时值的一般行为，而拷贝是当数据仅存储在栈上时值的特殊行为，值的克隆则不会自动发生，需要程序员的显式调用。这隐含了 Rust 在设计时的一个选择：不自动进行数据的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">深拷贝</a>”。可以认为任何<strong>自动</strong>的复制对运行时性能的影响较小。</p>
<h3 id="扩展到函数">扩展到函数</h3>
<p>事实上，几乎所有的编程语言中都有函数（或者类似的概念），而函数的调用涉及到值的传递和返回，因此我们还需要考虑在涉及到函数时，值和所有权的行为。由于向函数传递值，类似于将值赋值给函数的参数，而函数返回值类似于将返回值赋值给调用者声明的一个变量（或者不可见的临时变量）。因此，一个将所有权扩展到函数的简单实现是，在向函数传递值以及函数返回值时，采用和赋值一样的行为。在 Rust 中，向函数传递值时值的行为和赋值时相同，可能会移动或者拷贝，同样的，函数的返回值也可以移动：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-title function_ invoke__">foo</span>(s1); <span class="hljs-comment">// s1 经由 foo 被移动给 s2</span><br>    <span class="hljs-comment">// s1 不再有效</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <span class="hljs-comment">// s 进入作用域</span><br>    s <span class="hljs-comment">// 返回 s 并移动给调用者</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>至此，通过所有权系统检查的代码中，值都能被正确地丢弃，空间都能被正确地回收，并且被移动过的值可以保证不会被再次使用。同时，这一切又都是高效的。</p>
<h2 id="引用和借用">引用和借用</h2>
<p>世界在拥有了所有权和移动语义后变得更好了，但是或许还不够好。比如，当我们实现的一个函数只希望使用一个参数的值，又不想获取所有权，并且调用者也希望在调用完成后继续使用它。在目前的世界里，函数需要在获取参数的所有权之后，在返回的时候再将该参数移动给调用者：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> (s2, len) = <span class="hljs-title function_ invoke__">length</span>(s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">length</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>(); <span class="hljs-comment">// len() 返回字符串的长度</span><br>    (s, len) <span class="hljs-comment">// 可以使用元组返回多个值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>尽管这样确实可行，而且对运行时的影响似乎也可以接受（只需要复制一些栈上的数据就行了），但是问题在于，没有人想要这样啰嗦地写代码。Rust 对此的解决方案是，提供了一个不获取值的所有权，但可以暂时获取值的使用权的功能，叫做<strong>引用</strong>（<em>Reference</em>）。</p>
<p>在 Rust 中，<strong>引用</strong>存储值的地址，我们可以根据该地址访问属于其它变量的值。在 Rust 中，指向类型为 <code>String</code> 的值的引用的类型为 <code>&amp;String</code>。对于类型为 <code>String</code> 的值 <code>s</code>，我们可以通过 <code>&amp;s</code> 创建一个指向 <code>s</code> 的引用。这些 <code>&amp;</code> 符号表示引用，而 Rust 将创建一个引用的行为称为<strong>借用</strong>（<em>Borrowing</em>）。同时，引用无需返回值来归还所有权，因为它不具有值的所有权，这与本节开始提出的需求是一致的。因此，我们可以改写本节开始的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">length</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-comment">// len() 返回字符串的长度</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="生命周期">生命周期</h3>
<p>事实上，许多编程语言中都有和引用类似的概念，但是在没有 GC 的语言中，引用（或者类似的功能）的使用可能会导致一些错误，比如[悬垂引用](Dangling Pointer)，即引用没有指向有效对象。而在 Rust 中，引用确保指向某个特定类型的有效值。引用有效性的保证依赖于<strong>生命周期</strong>（<em>Lifetime</em>）机制，它是与所有权机制同等重要的内存管理机制。</p>
<p>生命周期是引用必须有效的代码区域（与作用域的概念接近）。与所有权机制相似，生命周期机制也要求编译器保证代码满足一些关于生命周期的规则，事实上，这由编译器中的<strong>借用检查器</strong>（<em>Borrow checker</em>）来保证。同样的，这些的规则的检查也发生在编译时，因此不会影响运行时效率。</p>
<p>考虑下面的程序，它有一个外部作用域和一个内部作用域：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span>;                <span class="hljs-comment">// ---------+-- &#x27;a</span><br>    &#123;                     <span class="hljs-comment">//          |</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;        <span class="hljs-comment">// -+-- &#x27;b  |</span><br>        r = &amp;x;           <span class="hljs-comment">//  |       |</span><br>    &#125;                     <span class="hljs-comment">// -+       |</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="hljs-comment">//          |</span><br>&#125;                         <span class="hljs-comment">// ---------+</span><br></code></pre></td></tr></table></figure>
<p>在注释中，我们将 <code>r</code> 的生命周期标记为 <code>'a</code>，将 <code>x</code> 的生命周期标记为 <code>'b</code>。显然，<code>'b</code> 块要比 <code>'a</code> 块小。在编译时，Rust 比较这两个生命周期的大小，并发现生命周期为 <code>'a</code> 的 <code>r</code> 引用了一个生命周期为 <code>'b</code> 的对象 <code>x</code>。由于生命周期 <code>'b</code> 比生命周期 <code>'a</code> 小，这意味着被引用的对象比它的引用者存在的时间更短，因此程序被拒绝编译。如果成功编译，这将导致悬垂引用。这是借用检查器需要检查的规则之一：一个引用的生命周期不超过其引用的对象的生命周期。</p>
<p>大部分时候，生命周期是隐含并可以推断的（比如在函数体内，局部引用的生命周期通常与作用域保持一致）。但在一些情况下，比如当引用跨越了函数边界（作为参数）时，这种时候，引用的生命周期和调用者有关，编译器此时缺乏足够的信息进行判断。为此，Rust 提供了一种可以描述多个引用生命周期相互的关系，而不影响其生命周期的功能，叫做<strong>生命周期注解</strong>（<em>Lifetime annotation</em>）。程序员可以通过生命周期注解，提供给编译器足够的信息，以便借用检查器可以进行分析。</p>
<h2 id="总结">总结</h2>
<p>或许你作为一名有经验的程序员，在编程中可能已经遵守了上述这些准则，但是 Rust 的贡献在于，它将这些准则和语言的设计良好地结合在一起，通过提高了编译器的能力，减轻了程序员编程时的负担，同时尽可能地避免性能上的损耗。事实上，除了内存安全方面，Rust 也通过许多设计尝试避免包括线程安全和类型安全在内的安全问题。而本文介绍的内容，也只是 Rust 中的冰山一角。</p>

            <script>
                var html = document.getElementById('Memory Management in Rust');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('Memory Management in Rust').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2022/02/17/Memory-Management-in-Rust/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/21/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8/">一点点复制移动</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 21, 2020</span>
        </div>
        <div class="post-pre" id="一点点复制移动">
            <p>也算是日经问题了, 但我太弱了, 还是得记一下, 首先看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;move ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = <span class="hljs-built_in">test</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy ctor<br>move ctor<br></code></pre></td></tr></table></figure>
<p>第一个 <code>copy ctor</code> 很好理解, 那么第二个是哪里的呢? 答案是 test 返回的时候, 首先因为 t 是形参, 所以在 return 这里不满足 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a> 的要求, 所以这里不会进行优化, 故需要调用一次构造函数, 比如我们把 <code>auto t2 = test(t1)</code> 修改为 <code>test(t1)</code>, 会发现输出没有改变</p>
<p>那为什么 <code>return t</code> 的时候调用的是移动构造函数而不是复制构造呢, 参见<a target="_blank" rel="noopener" href="http://eel.is/c++draft/class.copy.elision#3">class.copy.elision #3</a>, 简单点说就是在需要复制语义时, 如果条件允许, 可以使用移动操作, 那么我们把移动构造删掉应该可以使用复制构造了吧, 那就改成下边这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = <span class="hljs-built_in">test</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码用 C++17 是可以编译的, 并且打印结果和预期一样, 是两个 copy ctor, 但是在 C++17 之前(以及 C++11 之后)编译是通不过的, 这又是为什么呢?</p>
<p>答案是在<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_initialization">复制初始化</a>的时候, 如果初始化器是一个右值, 重载决议的时候会选择移动构造, 而如果移动构造被显式弃置(delete)了, 就会报错, 但是在 C++17 之后, 因为 copy elision 是强制的, 所以这里不需要调用移动构造, 从而也就不会报错, 比如我们还是把 <code>auto t2 = test(t1)</code> 改成 <code>test(t1)</code>, 在 C++17 之前也可以通过编译了</p>
<p>但是除此之外还有一个问题, 当我们把显式弃置移动构造的语句删掉时, 变成下边这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = <span class="hljs-built_in">test</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还是可以正常通过编译的, 尽管当用户声明了复制构造函数之后, 移动构造函数不会被隐式声明, 但是重载决议会忽略掉这件事, 因为会阻止从右值复制初始化, 参见<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/move_constructor">移动构造函数一节</a>中所述:</p>
<blockquote>
<p>The deleted implicitly-declared move constructor is ignored by overload resolution (otherwise it would prevent copy-initialization from rvalue).</p>
</blockquote>

            <script>
                var html = document.getElementById('一点点复制移动');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('一点点复制移动').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/21/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/17/%E6%89%AF%20C++%20%E9%87%8C%E7%9A%84%20Lambda/">扯 C++ 里的 Lambda</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 17, 2020</span>
        </div>
        <div class="post-pre" id="扯 C++ 里的 Lambda">
            <p>之前写(抄) parsec 的时候, 在重载 <code>operator&gt;&gt;</code> 的时候, <code>operator&gt;&gt;</code> 需要接收一个 lambda, 之后返回一个 <code>Component&lt;R&gt;</code>, 其中 R 是接收 lambda 的返回值类型, 所以就要搞到 lambda 对应的函数类型</p>
<p>在一开始我是直接用 <code>std::function</code> 做的, 但是众所周知, 下面这样的写法是匹配不了的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Args&gt;<br>ParsecComponent&lt;R&gt; <span class="hljs-keyword">operator</span>&gt;&gt;(std::function&lt;<span class="hljs-built_in">R</span>(Args...)&gt; callback) &#123;<br>    ParsecComponent&lt;R&gt; component;<br>    ...<br>    <span class="hljs-keyword">return</span> component;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为 lambda 表达式到 std::function 要进行类型转换, 毕竟是两个类型, 所以指明 std::function 的模板实参的时候才能进行 lambda -&gt; std::function 的隐式转换, 不过一开始为了偷懒, 而且我只需要拿到 lambda 的返回值类型, 就这样写了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&gt;&gt;(Func &amp;&amp;callback) &#123;<br>    <span class="hljs-keyword">using</span> NewResult = <span class="hljs-keyword">typename</span> <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">function</span>(callback))::result_type;<br>    ParsecComponent&lt;NewResult&gt; component;<br>    ...<br>    <span class="hljs-keyword">return</span> component;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以说 <code>auto</code> 这种东西还真是好用啊, 类型还可以拖延到函数体里做(</p>
<p>这样做总归有种脱裤子放屁的感觉, 那么怎么不通过 std::function 就能拿到 lambda 表达式对应的函数类型呢?</p>
<p>众所周知, 每一个 lambda 表达式的类型都是不一样的, 比如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Func &amp;&amp;f)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(Func).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>([]()&#123;&#125;);<br>    <span class="hljs-built_in">print</span>([]()&#123;&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我这里输出的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Z4mainE3$_0<br>Z4mainE3$_1<br></code></pre></td></tr></table></figure>
<p>毕竟如果要每个定义相同的 lambda 的类型相同是不现实而而且没有必要的, 何况还有闭包捕获之类的复杂性需要考虑, 但是众所周知, lambda 返回的是一个对象, 也即它的类型重载了 <code>operator()</code>, 而 <code>operator()</code> 又是一个函数, 那么我们不久可以通过推导其重载的 <code>operator()</code> 函数类型拿到 lambda 对应的函数类型了吗(</p>
<p>所以这件事情很清晰明了了, 我们只需要拿到 lambda 表达式产生的匿名类型, 然后根据类成员函数寻址到它的 <code>operator()</code>, 然后推导出 <code>operator()</code> 的函数签名就可以了!</p>
<p>那就划分成三步吧</p>
<h2 id="一-得到-lambda-对应的匿名类类型">一, 得到 lambda 对应的匿名类类型</h2>
<p>这一步是很简单的, 因为只要模板实参自动推导一下就出来了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Func &amp;&amp;lambda)</span></span>;<br></code></pre></td></tr></table></figure>
<p>那现在这个 Func 就是我们需要的类型</p>
<h2 id="二-推导-Func-重载的-operator-函数签名">二, 推导 Func 重载的 <code>operator()</code> 函数签名</h2>
<p>因为当前我们只有一个 Func 类型, 但是如果要获取 <code>operator()</code> 的签名的话, 我们还需要对 <code>operator()</code> 的类型做一个特化, 比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ClassType, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span>&lt;<span class="hljs-built_in">R</span>(ClassType::*)(Args...) <span class="hljs-type">const</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> result_type = R;<br>    <span class="hljs-keyword">using</span> args_type = std::tuple&lt;Args...&gt;;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> index&gt;<br>    <span class="hljs-keyword">using</span> arg_type_at = std::<span class="hljs-type">tuple_element_t</span>&lt;index, args_type&gt;;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> arity = <span class="hljs-keyword">sizeof</span>...(Args);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>很简单对吧, 只需要对类的成员函数的类型做一个特化就好了</p>
<p>其实这个时候已经可以用了, 比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func,<br>    <span class="hljs-keyword">typename</span> R = <span class="hljs-keyword">typename</span> lambda_traits&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-built_in">operator</span>())&gt;::result_type&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">foo</span>(Func &amp;&amp;lambda);<br></code></pre></td></tr></table></figure>
<h2 id="三-包装一下">三, 包装一下</h2>
<p>其实可以看到第二步的时候已经可以用了, 那么我们只需要把调用的过程包装一下, 但是由于我们拿到的是一个 Func, 所以需要把之前的 <code>lambda_traits</code> 变成基类, 然后另 Func 实例化的模板类继承它就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits_base</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ClassType, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits_base</span>&lt;<span class="hljs-built_in">R</span>(ClassType::*)(Args...) <span class="hljs-type">const</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> result_type = R;<br>    <span class="hljs-keyword">using</span> args_type = std::tuple&lt;Args...&gt;;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> index&gt;<br>    <span class="hljs-keyword">using</span> arg_type_at = std::<span class="hljs-type">tuple_element_t</span>&lt;index, args_type&gt;;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> arity = <span class="hljs-keyword">sizeof</span>...(Args);<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-built_in">operator</span>())&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>支持 C++17 的 lambda 现在是没有问题了, 那么有人要问了, C++20 的 lambda 是支持模板 operator() 的, 这个显然是不支持的啊, 是垃圾</p>
<p>那就来接轨一哈 20 吧, 反正接轨了之后是不影响 17 的 lambda 推导的</p>
<hr>
<p>支持 template operator() 的 lambda 顾名思义就是长这样子的啦:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> foo = []&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Args&gt;(Args...) -&gt; T &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(); &#125;;<br>foo.<span class="hljs-built_in">operator</span>()&lt;...&gt;(...);<br></code></pre></td></tr></table></figure>
<p>可以看出来(目前)如果要调用这个 lambda 的话, 我们需要显式地指明模板的实参, 所以在推导的时候, 模板实参的信息也是要提供的, 那么只需要简单地修改一下我们的 lambda_traits:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;Args...&gt;)&gt; &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-built_in">operator</span>())&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>这样一来就可以了, 不过还有一种特殊情况, 比如说我们有一个这样类似提供了 template operator() 的类:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当我们在获取他无模板实参的 operator() 时, 我们只能通过 <code>&amp;Foo::template operator()&lt;&gt;</code> 而不能写 <code>&amp;Foo::operator()</code>, 当然这也是显而易见的, 不过如果我们的 lambda 支持的 template operator() 能够接收无实参的实例化的话, 就会导致前边的 lambda_traits 失效, 所以我们需要在模板实参 Args 为空的时候判断一下要取 <code>operator()</code> 还是 <code>template operator()&lt;&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">void_t</span>&lt;&gt;&gt;<br><span class="hljs-keyword">struct</span> call_which &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-built_in">operator</span>());<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">call_which</span>&lt;T, std::<span class="hljs-type">void_t</span>&lt;<span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;&gt;)&gt;&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;&gt;);<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">call_which_t</span> = <span class="hljs-keyword">typename</span> call_which&lt;T&gt;::type;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda&lt;<span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;Args...&gt;)&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span>&lt;T&gt; : lambda&lt;<span class="hljs-type">call_which_t</span>&lt;T&gt;&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>通过 <code>void_t</code> 判断了一下是不是具有 <code>template operator()&lt;&gt;</code> 就可以了</p>

            <script>
                var html = document.getElementById('扯 C++ 里的 Lambda');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('扯 C++ 里的 Lambda').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/17/%E6%89%AF%20C++%20%E9%87%8C%E7%9A%84%20Lambda/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/15/C++%20%E5%AE%9E%E7%8E%B0%20Parsec/">C++ 实现 Parsec</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 15, 2020</span>
        </div>
        <div class="post-pre" id="C++ 实现 Parsec">
            <p>前一段时间看到了梨梨喵聚聚写的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25411428">Parser Combinator 在 C++ 里的 DSL</a>, 感觉好厉害, 正好毕设里要写一部分前端, 昨天又把这篇文章看了一遍, 想着我也要用这么酷炫的东西来参与一下毕设, 于是今天仿了一个, 不过由于电脑屏幕太小(理由), 看不懂梨梨喵聚聚的代码, 只好照着文章里的理念自己试着实现一下, 类的设计应该差不多, 不过具体的实现应该鶸了很多, 代码在<a target="_blank" rel="noopener" href="https://github.com/MU001999/parsec">parsec</a>, 目前还不支持左递归和垃圾回收(</p>
<p>先上一个加减的小例子吧:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Parsec&lt;<span class="hljs-type">char</span>&gt; Decimal;<br>Parsec&lt;string&gt; Number;<br>Parsec&lt;<span class="hljs-type">int</span>&gt; Primary, Additive, Additive_;<br><br><span class="hljs-comment">// Decimal := &#x27;0&#x27; | ... | &#x27;9&#x27;</span><br>Decimal = (<span class="hljs-string">&#x27;0&#x27;</span>_T | <span class="hljs-string">&#x27;1&#x27;</span>_T | <span class="hljs-string">&#x27;2&#x27;</span>_T | <span class="hljs-string">&#x27;3&#x27;</span>_T | <span class="hljs-string">&#x27;4&#x27;</span>_T | <span class="hljs-string">&#x27;5&#x27;</span>_T | <span class="hljs-string">&#x27;6&#x27;</span>_T | <span class="hljs-string">&#x27;7&#x27;</span>_T | <span class="hljs-string">&#x27;8&#x27;</span>_T | <span class="hljs-string">&#x27;9&#x27;</span>_T );<br><br><span class="hljs-comment">// Number := Decimal Number | Decimal</span><br>Number =<br>    (Decimal + Number &gt;&gt;<br>        [](<span class="hljs-type">char</span> decimal, string number) &#123;<br>            <span class="hljs-keyword">return</span> decimal + number;<br>        &#125;) |<br>    (Decimal &gt;&gt;<br>        [](<span class="hljs-type">char</span> decimal) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>() + decimal;<br>        &#125;);<br><br><span class="hljs-comment">// Primary := Number</span><br>Primary = Number &gt;&gt; [](string number) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(number);<br>&#125;;<br><br><span class="hljs-comment">// Additive := Primary Additive_ | Primary</span><br><span class="hljs-comment">// Additive_ := + Additive | - Additive</span><br>Additive =<br>    (Primary + Additive_ &gt;&gt;<br>        [](<span class="hljs-type">int</span> primary, <span class="hljs-type">int</span> additive) &#123;<br>            <span class="hljs-keyword">return</span> primary + additive;<br>        &#125;) |<br>    (Primary &gt;&gt; [](<span class="hljs-type">int</span> primary) &#123;<br>        <span class="hljs-keyword">return</span> primary;<br>    &#125;);<br>Additive_ = ((<span class="hljs-string">&#x27;+&#x27;</span>_T | <span class="hljs-string">&#x27;-&#x27;</span>_T) + Additive &gt;&gt; [](<span class="hljs-type">char</span> op, <span class="hljs-type">int</span> additive) &#123;<br>    <span class="hljs-built_in">return</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> ? additive : -additive);<br>&#125;);<br><br>cout &lt;&lt; <span class="hljs-built_in">Additive</span>(<span class="hljs-string">&quot;1+2+3&quot;</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>例子是改的梨梨瞄聚聚的, 因为不支持左递归, 只能手动提取公因子了(</p>
<p>和梨梨瞄聚聚重复的原理部分就不说了, 想知道的可以看一下梨梨瞄聚聚的那篇文章, 说一下不一样的地方吧, 我的实现里的类型笛卡尔乘积的结果使用 std::tuple&lt;Ts…&gt; 表示的, 类型的和的结果用 std::variant&lt;Ts…&gt; 表示, 当返回值的类型可能有多类型的时候就可以使形参的类型为 std::variant&lt;Ts…&gt;, 保证类型安全的同时还能接收多个类型的结果, 同样可以令组合子返回的是一个 tuple 类型, 可以继续和其它类型相乘或者相加, 后边就可以简化实现.</p>
<p>写了好几个小时, 虽然代码不多, 但是模板多起来密度太大真的眼花缭乱, 希望之后能支持一下左递归之类的操作吧, 毕竟还要拿来写毕设, 边用边改吧(</p>

            <script>
                var html = document.getElementById('C++ 实现 Parsec');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('C++ 实现 Parsec').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/15/C++%20%E5%AE%9E%E7%8E%B0%20Parsec/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/09/%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E6%97%B6%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">模板实现编译时冒泡排序</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 09, 2020</span>
        </div>
        <div class="post-pre" id="模板实现编译时冒泡排序">
            <p>看到特首写了个编译时的归并，感觉挺好玩，写了个冒泡试试，第一次用模板写这种东西，见笑了（</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vals</span> &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ValueAt</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val0, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ValueAt</span>&lt;i, Vals&lt;val0, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> val = ValueAt&lt;i - <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::val;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val0, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ValueAt</span>&lt;<span class="hljs-number">0</span>, Vals&lt;val0, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> val = val0;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combine</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> ...vals1, <span class="hljs-type">int</span> ...vals2&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combine</span>&lt;Vals&lt;vals1...&gt;, Vals&lt;vals2...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;vals1..., vals2...&gt;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>&lt;i, Vals&lt;val, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val&gt;, <span class="hljs-keyword">typename</span> SwapValue&lt;i - <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::type&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>&lt;<span class="hljs-number">0</span>, Vals&lt;val1, val2, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val2&gt;, <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val1&gt;, Vals&lt;vals...&gt;&gt;::type&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>&lt;<span class="hljs-number">0</span>, Vals&lt;val1, val2&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;val2, val1&gt;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span><br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> <span class="hljs-type">conditional_t</span>&lt;(ValueAt&lt;j - <span class="hljs-number">1</span>, T&gt;::val &gt; ValueAt&lt;j, T&gt;::val),<br>        BubbleSort&lt;i, j + <span class="hljs-number">1</span>, <span class="hljs-keyword">typename</span> SwapValue&lt;j - <span class="hljs-number">1</span>, T&gt;::type&gt;,<br>        BubbleSort&lt;i, j + <span class="hljs-number">1</span>, T&gt;&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span>&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, Vals&lt;val&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;val&gt;;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> j, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span>&lt;<span class="hljs-keyword">sizeof</span>...(vals), j, Vals&lt;vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;vals...&gt;;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span>&lt;i, <span class="hljs-keyword">sizeof</span>...(vals), Vals&lt;vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> BubbleSort&lt;i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::type;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sort</span><br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> BubbleSort&lt;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, T&gt;::type;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> ...vals&gt; <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Vals&lt;vals...&gt;)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> vs = &#123; vals... &#125;;<br>    <span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(vs), <span class="hljs-built_in">end</span>(vs), <span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(cout, <span class="hljs-string">&quot; &quot;</span>));<br>    <span class="hljs-built_in">endl</span>(cout);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">print</span>(Sort&lt;Vals&lt;<span class="hljs-number">1</span>&gt;&gt;::<span class="hljs-built_in">type</span>());<br>    <span class="hljs-built_in">print</span>(Sort&lt;Vals&lt;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&gt;&gt;::<span class="hljs-built_in">type</span>());<br>    <span class="hljs-built_in">print</span>(Sort&lt;Vals&lt;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&gt;&gt;::<span class="hljs-built_in">type</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码本身很简单，就是冒泡的思路，递归 j 的终止条件应该还可以优化一下</p>

            <script>
                var html = document.getElementById('模板实现编译时冒泡排序');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('模板实现编译时冒泡排序').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/09/%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E6%97%B6%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/02/24/%E9%80%9A%E8%BF%87%20call-cc%20%E7%BB%99%20Ice%20%E5%AE%9E%E7%8E%B0%20Coroutine/">通过 call-cc 给 Ice 实现 Coroutine</a>
        </div>
        <div class="post-meta">
            <span class="post-time">February 24, 2020</span>
        </div>
        <div class="post-pre" id="通过 call-cc 给 Ice 实现 Coroutine">
            <p>前两天给 Ice 加了 call/cc, 为此还重构了一波, 实现 call/cc 还是因为看了轮子哥的大专系列（</p>
<p>里边说提供 continuation 语言实现 Coroutine 起来很轻松, 后来又查了一些资料, 都说 continuation 表达能力很强, 就实现了一手, 调用方式完全等同 call/cc, 既然是看 Coroutine 才要实现 call/cc, 那实现了之后当然要用 call/cc 实现一手 Coroutine 了(</p>
<p>不过这个 Coroutine 比较简陋, 只提供 create, resume, yield, destroy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">coroutine: (@() &#123;<br>    @funcs: [];<br>    @conts: [];<br>    @deletes: [];<br>    @co_cont: none;<br><br>    @create(func) &#123;<br>        if deletes.empty() &#123;<br>            @id: funcs.size();<br>            funcs.push(func);<br>            conts.push(none);<br>            return id;<br>        &#125; else &#123;<br>            @id: deletes.pop();<br>            funcs[id]: func;<br>            conts[id]: none;<br>            return id;<br>        &#125;<br>    &#125;<br><br>    @resume(id) &#123;<br>        if conts[id] = none &#123;<br>            conts[id]: call_with_current_continuation(@(cont) &#123;<br>                co_cont: cont;<br>                funcs[id]();<br>            &#125;);<br>        &#125; else &#123;<br>            conts[id]: call_with_current_continuation(@(cont) &#123;<br>                co_cont: cont;<br>                conts[id](none);<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    @yield() &#123;<br>        call_with_current_continuation(co_cont);<br>    &#125;<br><br>    @destroy(id) &#123;<br>        funcs[id]: conts[id]: none;<br>        deletes.push(id);<br>    &#125;<br><br>    return @() &#123;&#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure>
<p>测试一下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@foo() &#123;<br>    @i: 0;<br>    while i &lt; 5 &#123;<br>        println(i: i + 1);<br>        coroutine.yield();<br>    &#125;<br>&#125;<br><br>@id1: coroutine.create(foo);<br>@id2: coroutine.create(foo);<br><br>@i: 0;<br>while i &lt; 5 &#123;<br>    coroutine.resume(id1);<br>    coroutine.resume(id2);<br>    i: i + 1;<br>&#125;<br><br>coroutine.destroy(id1);<br>coroutine.destroy(id2);<br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1<br>1<br>2<br>2<br>3<br>3<br>4<br>4<br>5<br>5<br></code></pre></td></tr></table></figure>
<p>里边唯一我觉得有点意思的地方是 resume 里, 直接在 lambda 里将当前的 continuation 绑定到 co_cont 上, 这样用户 create 的时候传入的函数就只需要调用 yield 了</p>
<p>可惜除了 vsc 都没有 Ice 的高亮(</p>

            <script>
                var html = document.getElementById('通过 call-cc 给 Ice 实现 Coroutine');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('通过 call-cc 给 Ice 实现 Coroutine').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/02/24/%E9%80%9A%E8%BF%87%20call-cc%20%E7%BB%99%20Ice%20%E5%AE%9E%E7%8E%B0%20Coroutine/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2019/10/02/C++%20%E7%9A%84%20Copy%20Elision%20%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/">C++ 的 Copy Elision 导致的奇怪问题</a>
        </div>
        <div class="post-meta">
            <span class="post-time">October 02, 2019</span>
        </div>
        <div class="post-pre" id="C++ 的 Copy Elision 导致的奇怪问题">
            <p>最近写设计模式作业的时候, 有一个作业是实现<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Decorator_pattern">装饰器模式 (Decorator Pattern)</a>, 由于我不会 Java, 所以只能用 C++ 来实现 :)</p>
<p>在这个背景下, 会有简单(表意)的几个类, 如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">inline</span> Base::~<span class="hljs-built_in">Base</span>() &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedA</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DerivedA</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">data_</span>(data) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> data_;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> data_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedB</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DerivedB</span>(<span class="hljs-type">const</span> Base &amp;pre) : <span class="hljs-built_in">pre_</span>(pre) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pre_.<span class="hljs-built_in">getData</span>() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> Base &amp;pre_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>简单来写就是上面这样, DerivedB 类型的对象可以接收以 Base 类作为基类的对象引用并且绑定到成员 pre_ 上, 在调用 getData 方法时会调用 pre_ 绑定的对象的 getData 方法, 并在其结果的基础上运算后返回</p>
<p>而这样的设计会导致一种很直觉的使用方法, 如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedA</span>(<span class="hljs-number">10</span>))).<span class="hljs-built_in">getData</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>也即嵌套对象, 实现 getData 的多次调用</p>
<p>但是这样的使用方式会造成与预期不符的结果出现, 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~&gt; g++ -std=c++17 test.cpp -o test<br>~&gt; ./test<br>11<br>~&gt; clang++ -std=c++17 test.cpp -o test<br>~&gt; ./test<br>11<br></code></pre></td></tr></table></figure>
<p>会发现结果表明, 只有一个 DerivedB 类型的对象被构造了出来, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">cppreference 的 copy elision 章节</a>中的解释部分有提到:</p>
<blockquote>
<p>Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, <strong>even if the copy/move constructor and the destructor have observable side-effects</strong>. The objects are constructed directly into the storage where they would otherwise be copied/moved to. <strong>The copy/move constructors need not be present or accessible</strong>, as the language rules ensure that no copy/move operation takes place, even conceptually:</p>
</blockquote>
<blockquote>
<ul>
<li>In a return statement, when the operand is a prvalue of the same class type (ignoring cv-qualification) as the function return type:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">T <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>();<br>&#125;<br><br><span class="hljs-built_in">f</span>(); <span class="hljs-comment">// only one call to default constructor of T</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>In the initialization of a variable, when the initializer expression is a prvalue of the same class type (ignoring cv-qualification) as the variable type:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">T x = <span class="hljs-built_in">T</span>(<span class="hljs-built_in">T</span>(<span class="hljs-built_in">f</span>())); <span class="hljs-comment">// only one call to default constructor of T, to initialize x</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面这句被我标粗的文字可以看到, 即使拷贝/移动构造有副作用, 依然只构造一次, 甚至不需要有拷贝/移动构造函数</p>
<p>可以在类中添加如下定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedB</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// new additions</span><br>    <span class="hljs-built_in">DerivedB</span>(<span class="hljs-type">const</span> DerivedB &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">DerivedB</span>(DerivedB &amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-built_in">DerivedB</span>(<span class="hljs-type">const</span> Base &amp;pre) : <span class="hljs-built_in">pre_</span>(pre) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pre_.<span class="hljs-built_in">getData</span>() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> Base &amp;pre_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>会发现依然可以通过编译并且运行结果与之前相同 ( 因为在 C++17 中 Copy Elision 已经不再是可选项 ), 但是在 C++17 之前如果 delete 了这两个拷贝/移动构造函数, 会导致无法通过编译, 尽管有可以匹配 const Base &amp; 类型的构造函数, 也依然不可以:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">test.cpp:45:13: error: functional-style cast from &#x27;DerivedB&#x27;<br>      to &#x27;DerivedB&#x27; uses deleted function<br>    cout &lt;&lt; DerivedB(DerivedB(DerivedA(10))).getData...<br>            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>test.cpp:31:5: note: candidate constructor has been<br>      explicitly deleted<br>    DerivedB(DerivedB &amp;&amp;) = delete;<br>    ^<br>test.cpp:30:5: note: candidate constructor has been<br>      explicitly deleted<br>    DerivedB(const DerivedB &amp;) = delete;<br>    ^<br>test.cpp:33:5: note: candidate constructor<br>    DerivedB(const Base &amp;pre) : pre_(pre) &#123;&#125;<br>    ^<br>1 error generated.<br></code></pre></td></tr></table></figure>
<p>感谢 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/lei-yu-10-27">禽牙</a> 在评论中提出, 事实上如果我们在尚未 delete 那两个构造函数通过如下的方式调用, 也依然不可行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DerivedA <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b1</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>;<br>cout &lt;&lt; b2.<span class="hljs-built_in">getData</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>结果依然是 11, 这是因为重载决议后其实我们调用的是匹配类型为 <code>const DerivedB &amp;</code> 的构造函数, 同样如果我们约定在代码中都是用这样的方式编写程序, 我们就可以获得一种解决方式, 编写匹配类型的构造函数, 如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-built_in">DerivedB</span>(<span class="hljs-type">const</span> DerivedB &amp;pre) : <span class="hljs-built_in">pre_</span>(pre) &#123;&#125;<br>...<br></code></pre></td></tr></table></figure>
<p>再通过声明中间变量的方式调用就可以获得正确结果, 但是通过纯右值的形式依然不行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-function">DerivedA <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b1</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function">DerivedB <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>;<br>cout &lt;&lt; b2.<span class="hljs-built_in">getData</span>() &lt;&lt; endl;<br><span class="hljs-comment">// print 12</span><br>...<br>cout &lt;&lt; <span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedA</span>(<span class="hljs-number">10</span>))).<span class="hljs-built_in">getData</span>() &lt;&lt; endl;<br><span class="hljs-comment">// print 11</span><br>...<br></code></pre></td></tr></table></figure>
<p>所以如何才能在这种设计下通过这种方式正常使用呢?</p>
<p>一种可以显著增加代码程度的方式是, 手动添加强制转换:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> Base &amp;&gt;(<span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedA</span>(<span class="hljs-number">10</span>)))).<span class="hljs-built_in">getData</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">DerivedB</span>((<span class="hljs-type">const</span> Base &amp;)(<span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedA</span>(<span class="hljs-number">10</span>)))).<span class="hljs-built_in">getData</span>() &lt;&lt; endl; <span class="hljs-comment">// C-style</span><br></code></pre></td></tr></table></figure>
<p>当然这种方式其实还是可以接受的</p>
<p>还有一种可以不会增加太多冗余代码的方式是在构造函数里增加一个冗余参数, 区分开就可以了, 比如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedB</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DerivedB</span>(<span class="hljs-type">const</span> Base &amp;pre, <span class="hljs-type">int</span>) : <span class="hljs-built_in">pre_</span>(pre) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pre_.<span class="hljs-built_in">getData</span>() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> Base &amp;pre_;<br>&#125;;<br>...<br>cout &lt;&lt; <span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedA</span>(<span class="hljs-number">10</span>), <span class="hljs-number">0</span>), <span class="hljs-number">0</span>).<span class="hljs-built_in">getData</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>当然以上两种都是在不涉及模板的情况下完成的, 但是都会对调用的方便性产生影响</p>
<p>还有一种不会更改调用方式, 通过模板区分嵌套的相同类型的方式, 感谢 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/91khr">91khr</a> 提供:</p>
<p>首先先将 DerivedB 变成一个类模板, 之后添加<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">模板推导指引</a>来实现嵌套区分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> Lv&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedB</span>;<br>...<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Ty&gt; <span class="hljs-built_in">DerivedB</span>(Ty) -&gt; DerivedB&lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> Lv&gt; <span class="hljs-built_in">DerivedB</span>(DerivedB&lt;Lv&gt;) -&gt; DerivedB&lt;Lv + <span class="hljs-number">1</span>&gt;;<br>...<br>cout &lt;&lt; <span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedB</span>(<span class="hljs-built_in">DerivedA</span>(<span class="hljs-number">10</span>))).<span class="hljs-built_in">getData</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>在此条件之下, 结果与预期相同, 完美解决问题:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~&gt; clang++ -std=c++17 test.cpp -o test<br>~&gt; ./test<br>12<br></code></pre></td></tr></table></figure>

            <script>
                var html = document.getElementById('C++ 的 Copy Elision 导致的奇怪问题');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('C++ 的 Copy Elision 导致的奇怪问题').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2019/10/02/C++%20%E7%9A%84%20Copy%20Elision%20%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/">Read More</a>
        </div>
    </article>
    
</section>

    </main>
    <div class="footer">Copyright &copy;&nbsp;<a href="/">Mu001999</a>&nbsp;|&nbsp;<a href="http://www.miibeian.gov.cn/" target="_blank">京ICP备17013700号</a></div>

</body>
</html>
