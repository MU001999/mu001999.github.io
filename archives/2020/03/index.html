<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Seek Truth</title>
    <meta charset="utf-8">
    <link rel="stylesheet"
        href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/vs.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/npm/clamp-js-main@0.11.6/clamp.min.js"></script>
    
<link rel="stylesheet" href="/css/font.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Seek Truth" type="application/atom+xml">
</head>

<body>
    <header class="header">
    <div class="blog-title">
        <a href="/" class="logo">Seek Truth</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                
                
                <li class="menu-item">
                    <a href="/" class="menu-item-link">Posts</a>
                </li>
            
                
                
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">RSS</a>
                </li>
            
                
                
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/MU001999" class="menu-item-link">Github</a>
                </li>
            
        </ul>
    </nav>
</header>

    <main class="main">
        <section class="posts">
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/21/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8/">一点点复制移动</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 21, 2020</span>
        </div>
        <div class="post-pre" id="一点点复制移动">
            <p>也算是日经问题了, 但我太弱了, 还是得记一下, 首先看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;move ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = <span class="hljs-built_in">test</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy ctor<br>move ctor<br></code></pre></td></tr></table></figure>
<p>第一个 <code>copy ctor</code> 很好理解, 那么第二个是哪里的呢? 答案是 test 返回的时候, 首先因为 t 是形参, 所以在 return 这里不满足 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a> 的要求, 所以这里不会进行优化, 故需要调用一次构造函数, 比如我们把 <code>auto t2 = test(t1)</code> 修改为 <code>test(t1)</code>, 会发现输出没有改变</p>
<p>那为什么 <code>return t</code> 的时候调用的是移动构造函数而不是复制构造呢, 参见<a target="_blank" rel="noopener" href="http://eel.is/c++draft/class.copy.elision#3">class.copy.elision #3</a>, 简单点说就是在需要复制语义时, 如果条件允许, 可以使用移动操作, 那么我们把移动构造删掉应该可以使用复制构造了吧, 那就改成下边这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = <span class="hljs-built_in">test</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码用 C++17 是可以编译的, 并且打印结果和预期一样, 是两个 copy ctor, 但是在 C++17 之前(以及 C++11 之后)编译是通不过的, 这又是为什么呢?</p>
<p>答案是在<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_initialization">复制初始化</a>的时候, 如果初始化器是一个右值, 重载决议的时候会选择移动构造, 而如果移动构造被显式弃置(delete)了, 就会报错, 但是在 C++17 之后, 因为 copy elision 是强制的, 所以这里不需要调用移动构造, 从而也就不会报错, 比如我们还是把 <code>auto t2 = test(t1)</code> 改成 <code>test(t1)</code>, 在 C++17 之前也可以通过编译了</p>
<p>但是除此之外还有一个问题, 当我们把显式弃置移动构造的语句删掉时, 变成下边这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(Test t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test t1;<br>    <span class="hljs-keyword">auto</span> t2 = <span class="hljs-built_in">test</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还是可以正常通过编译的, 尽管当用户声明了复制构造函数之后, 移动构造函数不会被隐式声明, 但是重载决议会忽略掉这件事, 因为会阻止从右值复制初始化, 参见<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/move_constructor">移动构造函数一节</a>中所述:</p>
<blockquote>
<p>The deleted implicitly-declared move constructor is ignored by overload resolution (otherwise it would prevent copy-initialization from rvalue).</p>
</blockquote>

            <script>
                var html = document.getElementById('一点点复制移动');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('一点点复制移动').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/21/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/17/%E6%89%AF%20C++%20%E9%87%8C%E7%9A%84%20Lambda/">扯 C++ 里的 Lambda</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 17, 2020</span>
        </div>
        <div class="post-pre" id="扯 C++ 里的 Lambda">
            <p>之前写(抄) parsec 的时候, 在重载 <code>operator&gt;&gt;</code> 的时候, <code>operator&gt;&gt;</code> 需要接收一个 lambda, 之后返回一个 <code>Component&lt;R&gt;</code>, 其中 R 是接收 lambda 的返回值类型, 所以就要搞到 lambda 对应的函数类型</p>
<p>在一开始我是直接用 <code>std::function</code> 做的, 但是众所周知, 下面这样的写法是匹配不了的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Args&gt;<br>ParsecComponent&lt;R&gt; <span class="hljs-keyword">operator</span>&gt;&gt;(std::function&lt;<span class="hljs-built_in">R</span>(Args...)&gt; callback) &#123;<br>    ParsecComponent&lt;R&gt; component;<br>    ...<br>    <span class="hljs-keyword">return</span> component;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为 lambda 表达式到 std::function 要进行类型转换, 毕竟是两个类型, 所以指明 std::function 的模板实参的时候才能进行 lambda -&gt; std::function 的隐式转换, 不过一开始为了偷懒, 而且我只需要拿到 lambda 的返回值类型, 就这样写了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&gt;&gt;(Func &amp;&amp;callback) &#123;<br>    <span class="hljs-keyword">using</span> NewResult = <span class="hljs-keyword">typename</span> <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">function</span>(callback))::result_type;<br>    ParsecComponent&lt;NewResult&gt; component;<br>    ...<br>    <span class="hljs-keyword">return</span> component;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以说 <code>auto</code> 这种东西还真是好用啊, 类型还可以拖延到函数体里做(</p>
<p>这样做总归有种脱裤子放屁的感觉, 那么怎么不通过 std::function 就能拿到 lambda 表达式对应的函数类型呢?</p>
<p>众所周知, 每一个 lambda 表达式的类型都是不一样的, 比如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Func &amp;&amp;f)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(Func).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>([]()&#123;&#125;);<br>    <span class="hljs-built_in">print</span>([]()&#123;&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我这里输出的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Z4mainE3$_0<br>Z4mainE3$_1<br></code></pre></td></tr></table></figure>
<p>毕竟如果要每个定义相同的 lambda 的类型相同是不现实而而且没有必要的, 何况还有闭包捕获之类的复杂性需要考虑, 但是众所周知, lambda 返回的是一个对象, 也即它的类型重载了 <code>operator()</code>, 而 <code>operator()</code> 又是一个函数, 那么我们不久可以通过推导其重载的 <code>operator()</code> 函数类型拿到 lambda 对应的函数类型了吗(</p>
<p>所以这件事情很清晰明了了, 我们只需要拿到 lambda 表达式产生的匿名类型, 然后根据类成员函数寻址到它的 <code>operator()</code>, 然后推导出 <code>operator()</code> 的函数签名就可以了!</p>
<p>那就划分成三步吧</p>
<h2 id="一-得到-lambda-对应的匿名类类型">一, 得到 lambda 对应的匿名类类型</h2>
<p>这一步是很简单的, 因为只要模板实参自动推导一下就出来了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Func &amp;&amp;lambda)</span></span>;<br></code></pre></td></tr></table></figure>
<p>那现在这个 Func 就是我们需要的类型</p>
<h2 id="二-推导-Func-重载的-operator-函数签名">二, 推导 Func 重载的 <code>operator()</code> 函数签名</h2>
<p>因为当前我们只有一个 Func 类型, 但是如果要获取 <code>operator()</code> 的签名的话, 我们还需要对 <code>operator()</code> 的类型做一个特化, 比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ClassType, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span>&lt;<span class="hljs-built_in">R</span>(ClassType::*)(Args...) <span class="hljs-type">const</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> result_type = R;<br>    <span class="hljs-keyword">using</span> args_type = std::tuple&lt;Args...&gt;;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> index&gt;<br>    <span class="hljs-keyword">using</span> arg_type_at = std::<span class="hljs-type">tuple_element_t</span>&lt;index, args_type&gt;;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> arity = <span class="hljs-keyword">sizeof</span>...(Args);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>很简单对吧, 只需要对类的成员函数的类型做一个特化就好了</p>
<p>其实这个时候已经可以用了, 比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func,<br>    <span class="hljs-keyword">typename</span> R = <span class="hljs-keyword">typename</span> lambda_traits&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-built_in">operator</span>())&gt;::result_type&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">foo</span>(Func &amp;&amp;lambda);<br></code></pre></td></tr></table></figure>
<h2 id="三-包装一下">三, 包装一下</h2>
<p>其实可以看到第二步的时候已经可以用了, 那么我们只需要把调用的过程包装一下, 但是由于我们拿到的是一个 Func, 所以需要把之前的 <code>lambda_traits</code> 变成基类, 然后另 Func 实例化的模板类继承它就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits_base</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ClassType, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits_base</span>&lt;<span class="hljs-built_in">R</span>(ClassType::*)(Args...) <span class="hljs-type">const</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> result_type = R;<br>    <span class="hljs-keyword">using</span> args_type = std::tuple&lt;Args...&gt;;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> index&gt;<br>    <span class="hljs-keyword">using</span> arg_type_at = std::<span class="hljs-type">tuple_element_t</span>&lt;index, args_type&gt;;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> arity = <span class="hljs-keyword">sizeof</span>...(Args);<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-built_in">operator</span>())&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>支持 C++17 的 lambda 现在是没有问题了, 那么有人要问了, C++20 的 lambda 是支持模板 operator() 的, 这个显然是不支持的啊, 是垃圾</p>
<p>那就来接轨一哈 20 吧, 反正接轨了之后是不影响 17 的 lambda 推导的</p>
<hr>
<p>支持 template operator() 的 lambda 顾名思义就是长这样子的啦:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> foo = []&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Args&gt;(Args...) -&gt; T &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(); &#125;;<br>foo.<span class="hljs-built_in">operator</span>()&lt;...&gt;(...);<br></code></pre></td></tr></table></figure>
<p>可以看出来(目前)如果要调用这个 lambda 的话, 我们需要显式地指明模板的实参, 所以在推导的时候, 模板实参的信息也是要提供的, 那么只需要简单地修改一下我们的 lambda_traits:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;Args...&gt;)&gt; &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda_traits_base&lt;<span class="hljs-keyword">decltype</span>(&amp;Func::<span class="hljs-built_in">operator</span>())&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>这样一来就可以了, 不过还有一种特殊情况, 比如说我们有一个这样类似提供了 template operator() 的类:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当我们在获取他无模板实参的 operator() 时, 我们只能通过 <code>&amp;Foo::template operator()&lt;&gt;</code> 而不能写 <code>&amp;Foo::operator()</code>, 当然这也是显而易见的, 不过如果我们的 lambda 支持的 template operator() 能够接收无实参的实例化的话, 就会导致前边的 lambda_traits 失效, 所以我们需要在模板实参 Args 为空的时候判断一下要取 <code>operator()</code> 还是 <code>template operator()&lt;&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">void_t</span>&lt;&gt;&gt;<br><span class="hljs-keyword">struct</span> call_which &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-built_in">operator</span>());<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">call_which</span>&lt;T, std::<span class="hljs-type">void_t</span>&lt;<span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;&gt;)&gt;&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;&gt;);<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">call_which_t</span> = <span class="hljs-keyword">typename</span> call_which&lt;T&gt;::type;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span> : lambda&lt;<span class="hljs-keyword">decltype</span>(&amp;T::<span class="hljs-keyword">template</span> <span class="hljs-built_in">operator</span>()&lt;Args...&gt;)&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lambda_traits</span>&lt;T&gt; : lambda&lt;<span class="hljs-type">call_which_t</span>&lt;T&gt;&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>通过 <code>void_t</code> 判断了一下是不是具有 <code>template operator()&lt;&gt;</code> 就可以了</p>

            <script>
                var html = document.getElementById('扯 C++ 里的 Lambda');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('扯 C++ 里的 Lambda').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/17/%E6%89%AF%20C++%20%E9%87%8C%E7%9A%84%20Lambda/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/15/C++%20%E5%AE%9E%E7%8E%B0%20Parsec/">C++ 实现 Parsec</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 15, 2020</span>
        </div>
        <div class="post-pre" id="C++ 实现 Parsec">
            <p>前一段时间看到了梨梨喵聚聚写的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25411428">Parser Combinator 在 C++ 里的 DSL</a>, 感觉好厉害, 正好毕设里要写一部分前端, 昨天又把这篇文章看了一遍, 想着我也要用这么酷炫的东西来参与一下毕设, 于是今天仿了一个, 不过由于电脑屏幕太小(理由), 看不懂梨梨喵聚聚的代码, 只好照着文章里的理念自己试着实现一下, 类的设计应该差不多, 不过具体的实现应该鶸了很多, 代码在<a target="_blank" rel="noopener" href="https://github.com/MU001999/parsec">parsec</a>, 目前还不支持左递归和垃圾回收(</p>
<p>先上一个加减的小例子吧:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Parsec&lt;<span class="hljs-type">char</span>&gt; Decimal;<br>Parsec&lt;string&gt; Number;<br>Parsec&lt;<span class="hljs-type">int</span>&gt; Primary, Additive, Additive_;<br><br><span class="hljs-comment">// Decimal := &#x27;0&#x27; | ... | &#x27;9&#x27;</span><br>Decimal = (<span class="hljs-string">&#x27;0&#x27;</span>_T | <span class="hljs-string">&#x27;1&#x27;</span>_T | <span class="hljs-string">&#x27;2&#x27;</span>_T | <span class="hljs-string">&#x27;3&#x27;</span>_T | <span class="hljs-string">&#x27;4&#x27;</span>_T | <span class="hljs-string">&#x27;5&#x27;</span>_T | <span class="hljs-string">&#x27;6&#x27;</span>_T | <span class="hljs-string">&#x27;7&#x27;</span>_T | <span class="hljs-string">&#x27;8&#x27;</span>_T | <span class="hljs-string">&#x27;9&#x27;</span>_T );<br><br><span class="hljs-comment">// Number := Decimal Number | Decimal</span><br>Number =<br>    (Decimal + Number &gt;&gt;<br>        [](<span class="hljs-type">char</span> decimal, string number) &#123;<br>            <span class="hljs-keyword">return</span> decimal + number;<br>        &#125;) |<br>    (Decimal &gt;&gt;<br>        [](<span class="hljs-type">char</span> decimal) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>() + decimal;<br>        &#125;);<br><br><span class="hljs-comment">// Primary := Number</span><br>Primary = Number &gt;&gt; [](string number) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(number);<br>&#125;;<br><br><span class="hljs-comment">// Additive := Primary Additive_ | Primary</span><br><span class="hljs-comment">// Additive_ := + Additive | - Additive</span><br>Additive =<br>    (Primary + Additive_ &gt;&gt;<br>        [](<span class="hljs-type">int</span> primary, <span class="hljs-type">int</span> additive) &#123;<br>            <span class="hljs-keyword">return</span> primary + additive;<br>        &#125;) |<br>    (Primary &gt;&gt; [](<span class="hljs-type">int</span> primary) &#123;<br>        <span class="hljs-keyword">return</span> primary;<br>    &#125;);<br>Additive_ = ((<span class="hljs-string">&#x27;+&#x27;</span>_T | <span class="hljs-string">&#x27;-&#x27;</span>_T) + Additive &gt;&gt; [](<span class="hljs-type">char</span> op, <span class="hljs-type">int</span> additive) &#123;<br>    <span class="hljs-built_in">return</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> ? additive : -additive);<br>&#125;);<br><br>cout &lt;&lt; <span class="hljs-built_in">Additive</span>(<span class="hljs-string">&quot;1+2+3&quot;</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>例子是改的梨梨瞄聚聚的, 因为不支持左递归, 只能手动提取公因子了(</p>
<p>和梨梨瞄聚聚重复的原理部分就不说了, 想知道的可以看一下梨梨瞄聚聚的那篇文章, 说一下不一样的地方吧, 我的实现里的类型笛卡尔乘积的结果使用 std::tuple&lt;Ts…&gt; 表示的, 类型的和的结果用 std::variant&lt;Ts…&gt; 表示, 当返回值的类型可能有多类型的时候就可以使形参的类型为 std::variant&lt;Ts…&gt;, 保证类型安全的同时还能接收多个类型的结果, 同样可以令组合子返回的是一个 tuple 类型, 可以继续和其它类型相乘或者相加, 后边就可以简化实现.</p>
<p>写了好几个小时, 虽然代码不多, 但是模板多起来密度太大真的眼花缭乱, 希望之后能支持一下左递归之类的操作吧, 毕竟还要拿来写毕设, 边用边改吧(</p>

            <script>
                var html = document.getElementById('C++ 实现 Parsec');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('C++ 实现 Parsec').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/15/C++%20%E5%AE%9E%E7%8E%B0%20Parsec/">Read More</a>
        </div>
    </article>
    
    <article class="post">
        <div class="post-title">
            <a class="post-title-link" href="/2020/03/09/%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E6%97%B6%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">模板实现编译时冒泡排序</a>
        </div>
        <div class="post-meta">
            <span class="post-time">March 09, 2020</span>
        </div>
        <div class="post-pre" id="模板实现编译时冒泡排序">
            <p>看到特首写了个编译时的归并，感觉挺好玩，写了个冒泡试试，第一次用模板写这种东西，见笑了（</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vals</span> &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ValueAt</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val0, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ValueAt</span>&lt;i, Vals&lt;val0, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> val = ValueAt&lt;i - <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::val;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val0, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ValueAt</span>&lt;<span class="hljs-number">0</span>, Vals&lt;val0, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> val = val0;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combine</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> ...vals1, <span class="hljs-type">int</span> ...vals2&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combine</span>&lt;Vals&lt;vals1...&gt;, Vals&lt;vals2...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;vals1..., vals2...&gt;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>&lt;i, Vals&lt;val, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val&gt;, <span class="hljs-keyword">typename</span> SwapValue&lt;i - <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::type&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>&lt;<span class="hljs-number">0</span>, Vals&lt;val1, val2, vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val2&gt;, <span class="hljs-keyword">typename</span> Combine&lt;Vals&lt;val1&gt;, Vals&lt;vals...&gt;&gt;::type&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapValue</span>&lt;<span class="hljs-number">0</span>, Vals&lt;val1, val2&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;val2, val1&gt;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span><br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> <span class="hljs-type">conditional_t</span>&lt;(ValueAt&lt;j - <span class="hljs-number">1</span>, T&gt;::val &gt; ValueAt&lt;j, T&gt;::val),<br>        BubbleSort&lt;i, j + <span class="hljs-number">1</span>, <span class="hljs-keyword">typename</span> SwapValue&lt;j - <span class="hljs-number">1</span>, T&gt;::type&gt;,<br>        BubbleSort&lt;i, j + <span class="hljs-number">1</span>, T&gt;&gt;::type;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> val&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span>&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, Vals&lt;val&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;val&gt;;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> j, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span>&lt;<span class="hljs-keyword">sizeof</span>...(vals), j, Vals&lt;vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = Vals&lt;vals...&gt;;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> ...vals&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BubbleSort</span>&lt;i, <span class="hljs-keyword">sizeof</span>...(vals), Vals&lt;vals...&gt;&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> BubbleSort&lt;i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, Vals&lt;vals...&gt;&gt;::type;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sort</span><br>&#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> BubbleSort&lt;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, T&gt;::type;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> ...vals&gt; <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Vals&lt;vals...&gt;)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> vs = &#123; vals... &#125;;<br>    <span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(vs), <span class="hljs-built_in">end</span>(vs), <span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(cout, <span class="hljs-string">&quot; &quot;</span>));<br>    <span class="hljs-built_in">endl</span>(cout);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">print</span>(Sort&lt;Vals&lt;<span class="hljs-number">1</span>&gt;&gt;::<span class="hljs-built_in">type</span>());<br>    <span class="hljs-built_in">print</span>(Sort&lt;Vals&lt;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&gt;&gt;::<span class="hljs-built_in">type</span>());<br>    <span class="hljs-built_in">print</span>(Sort&lt;Vals&lt;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&gt;&gt;::<span class="hljs-built_in">type</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码本身很简单，就是冒泡的思路，递归 j 的终止条件应该还可以优化一下</p>

            <script>
                var html = document.getElementById('模板实现编译时冒泡排序');
                if (navigator.userAgent.indexOf('AppleWebKit') != -1){
                    $clamp(html, {clamp: 5, useNativeClamp: false});
                } else {
                    $clamp(html, {clamp: 5, useNativeClamp: true});
                }
                document.getElementById('模板实现编译时冒泡排序').value = html;
            </script>
        </div>
        <div class="post-read-more">
            <a href="/2020/03/09/%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E6%97%B6%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">Read More</a>
        </div>
    </article>
    
</section>

    </main>
    <div class="footer">Copyright &copy;&nbsp;<a href="/">Mu001999</a>&nbsp;|&nbsp;<a href="http://www.miibeian.gov.cn/" target="_blank">京ICP备17013700号</a></div>

</body>
</html>
